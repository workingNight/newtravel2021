## 前言 算法三大关键
递归 循环 选择，所有的算法最本质里面都是这几个

## 剑指offer思路分析

1. 数组中重复的数字。
在一个长度为n的数组里面所有的数字都在0-n-1的范围内。数组中某些数字是重复的，找出数组中任意一个重复的数字.
分为修改数组与不修改数组
> 修改数组，利用交换
> 不修改数组，利用辅助数组或者利用二分法查找

2. 有序二位数组中的查找
从一个角落开始排查。

3. 替换空格
js可以直接用正则，书上的C++的思路是先遍历出多少个空格再进行从后到前的移动，要注意边界条件。

4. 从尾到头打印链表
利用栈来保存再输出，或者直接用递归。但是当链表非常长的时候会导致函数调用的层级很深，可能会导致函数调用栈溢出

5. 重建二叉树
分析出中序和先序的根节点的规则后建立递归模型。

6. 二叉树中序遍历的下一个节点
画图进行分析，中序遍历为左根右
> 当前节点的情况分析： 如果有右子树，那下一个节点便是右子树的最左叶节点。
> 如果没有右子树，分情况讨论，1.如果当前节点是父节点的左子节点，那么下一个节点就是其父节点  2. 如果当前节点是父节点的右子树，那么往父节点一直遍历上去，直到该父节点是其父节点的左子节点，那么目标就是这个。


7. 用两个栈实现队列
栈1栈2，当要输出时栈2负责输出，当栈2为空时，栈1往栈2倾倒

8. 用2个队列实现栈
队列的特点，先进先出，也即头节点出，尾节点进。2个队列模拟栈，当要弹出栈尾的时候，其实就是把队列1中前面的元素都转移到队列2中去，就留最后一个元素，这个时候就是可以让队尾元素从队头里面出来了。

9. 斐波那契数列
递归实现和迭代实现，用one和two进行缓存

10. 旋转数组的最小数字
一个指针指向第一个元素，一个指针指向最后一个元素，两个都往中间移动，当他们相邻时，第二个指针将指向目标元素。但是如果碰到数组中有多个重复数字的情况，这个时候就需要顺序找了。

11. 矩阵中的路径
回溯法

12. 机器人的运动范围
同回溯

13. 剪绳子
请把绳子剪成m段，使得乘积最大，动态规划和贪婪算法。

14. 二进制中1的个数
技巧：把一个整数减去1再和原整数进行与运算会把该整数最右边的1变成0.那么一个整数的二进制表示中有多少个1就可以进行多少次这样的运算。
```
int NumberOf1(int n) {
    int count = 0;
    while(n) {
        ++ count;
        n = (n-1)&n;
    }
    return count;
}
```

15. 数值的整数次方
a的n次方公式，n为偶数情况、n为奇数情况。

16. 打印从1到最大的n位数


17. 删除链表的节点
把目标节点的后面的节点的值往前覆盖，然后在删除后面的节点。   
删除链表中重复的节点。

18. 正则表达式匹配

19. 表示数值的字符串
字符串判断

20. 调整数组顺序使奇数位于偶数前面
维护两个指针，一个只向前移动，一个只向后运动，发现有偶数出现在奇数的前面，交换他们的顺序

21. 链表中倒数第K个节点
两个指针一个先走K位，然后再同步走到头

22. 链表中环的入口节点
特点；如果两个指针，一个走一格，一个走2格，他们最终相遇的地方一定是在环内，也就是说这个时候，如果在环内的这个元素走一环回到原地的步数就是环数。获得环数之后，让一个指针先走环数，然后再同步走，他们相遇的时候就链表中环的入口节点。

23. 反转链表。
维护2个指针，一步一步走并且维护好断链和补链。需要注意的是，链表头指针为空，链表只有一个节点的特殊情况

24. 合并2个排序的链表
想清楚合并的过程，利用递归

25. 树的子结构
输入2棵二叉树，判断B是不是A的子结构。也是利用递归。根节点比较不成再让左右子树比较。

26. 二叉树的镜像
前序遍历这棵书的每个节点，如果遍历到的节点有子节点，就交换它的两个子节点。当交换完所有非叶节点的左右子节点后就得到了树的镜像。

27. 对称的二叉树
判断一棵二叉树是否是对称的，我们可以通过比较二叉树的前序遍历序列和对称前序遍历序列来判断二叉树是不是对称的，1左与2右比较，1右与2左比较

28. 顺时针打印矩阵
我们选取矩阵中左上角作为我们的初始，最后一圈可能会退化成只有一行，只有一列，甚至只有一个数字，打印这样的一圈就不再需要4步。每一步都有其循环限制条件，注意提取。i<endX , START < ENDY, START < ENDx, start < endY, start < endY - 1

29. 包含min函数的栈
一个辅助栈，每次把最小值往里压入，如果没有就压辅助栈中的最小元素重复压。

30. 栈的压入、弹出序列
判断序列是否是一个压栈序列的弹出序列，弹出序列的第一个值中的前面元素都要先压入，然后没有的时候都要去压入序列中找。

31. 从上到下打印二叉树
也即层序遍历二叉树，用一个队列进行辅助即可。要分行打印的话，就需要维护2个变量，一个变量表示在当层中还没有打印的节点数，另一个变量表示下一层节点的数目。
> 之字形打印二叉树
用两个栈进行辅助，当前打印的是奇数层，先保存左子节点再保存右子节点，如果当前打印的是偶数层，先保存右子节点再保存左子节点到第二个栈里面。

32. 二叉搜索树的后序遍历
后序遍历，左右根。利用递归，左子树节点值都小于根节点的值，

33. 二叉树中和为某一值的路径
输入一颗二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。利用一个辅助栈

34. 复杂链表的复制
用哈希表，或者根据原链表的每个节点N创建对应的N’,我们把N‘链再N的后面，设置复制出来的链表的指针，最后再分离

35. 二叉搜索树与双向链表
利用递归，中序遍历。

36. 序列化二叉树和反序列化二叉树

37. 字符串的排列
输入一个字符串，打印出该字符串中字符的所有排列。我们可以把问题分化，把字符串看成第一个字符，与后面余下的字符2部分，然后再把第一个字符与后面部分的每个字符进行交换。然后我们可以把这个后面余下的字符然后进行上面一样的套路。

38. 数组中超过一般的数字
利用快排的partition划分，或者根据数组特点，也就是说这个数字出现的数字比其他所有的数字出现的次数的和还要多。 我们在遍历数组的时候保存2个值，一个是数组中的数字，一个是次数，如果出现不一样数字就减1，如果次数为0我们就保存下一个数字并把次数记为1.

39. 最小的K个数
输入n个整数，找出其中的最小的K个数。利用partition函数就可以了。
> 时间复杂度为nlogK的算法，适合处理行量数据
我们先创建一个大小为K的数据容器来存储最小的K个数字，接下来每次从输入的n个整数中读入一个数。利用最大堆。优点： 没有修改输入的数据，适合海量数据的输入。

40. 数据流中的中位数

41. 连续子数组的最大和
输入一个整数数组，数组里有正数也有负数。分析过程发现规律

42. 1~n整数中1出现的次数
输入一个整数n，求1~n这n个整数的十进制表示中1出现的次数。每次去掉最高位进行递归，递归的次数和位数相同。

43. 数字序列中某一位的数字
找出某些规律从而跳出若干数字

44. 把数组排成最小的数
排序规则

45. 把数字翻译成字符串
正则

46. 礼物的最大价值
动态规划，递归有大量重复的计算，递归的代码不是最优的，基于循环的代码效率要高很多。一个辅助数组

47. 最长不含重复字符的子字符串

48. 丑数
只包含因子2、3、5的数称为丑数，习惯上我们把1当成第一个丑数。
如果是丑数因子的公倍数也是丑数，我们可以用此来减少不必要的计算。

49. 第一个只出现一次的字符
哈希表

50. 数组中的逆序对
利用归并排序的思路。

51. 两个链表的第一个公共节点
先遍历两个链表得到他们的长度，然后先在较长链表上先走差值步，然后再同步走，他们相遇的时候就找到了公共节点。

52. 在排序数组中查找数字
数字在数组中出现的次数、0~n-1中缺失的数字（基于二分查找法），数组中数字与下标相等的情况。

53. 二叉搜索树的第K大节点
中序遍历一下即可找到

54. 二叉树的深度
基于递归，对遍历的代码稍作修改即可；
判断一棵树是否是平衡二叉树。用后序遍历的方式遍历二叉树的每个节点，在进行遍历到一个节点的时候我们就已经遍历了他的左右子树，只要在遍历每个节点的时候记录他的深度，我们就可以一边遍历一边判断每个节点是不平衡的。

56. 数组中数字的出现次数
异或运算

57. 递增排序和为S的数字
两个指针，一左一右往中间移动。

58. 翻转字符串
先翻转整体，再翻转单个字符
;左旋转字符串，把字符串分两部分，类似上面翻转字符串的炒作即可

59. 队列的最大值
一个滑动窗口的最大值

60. n个骰子的点数
基于递归和基于迭代来进行求值

61. 扑克牌中的顺子
把数组排序；统计数组中0的个数；数组中的空缺总数小于或者等于0的个数，那么这个数组就是连续的；反之不连续；若数组中有非0的重复数字，也不可能是连续的

62. 圆圈中最后剩下的数字
也称有名的约瑟夫环问题。用环形链表模拟圆圈的经典解法，也可以分析每次被删除的数字的规律并计算出圆圈中最后剩下的数字。映射为
```
f(n,m) = 
{
    0                       n=1
    [f(n-1,m) + m] % n      n > 1
}
```

63. 股票的最大利润
用min保存前i-1个数字的最小值

64. 求1+2+...+n

65. 不用乘除做加减法
利用位运算

66. 构建乘积数组

