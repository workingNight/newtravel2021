## js核心原理精讲——若离    

## 随笔、散笔记
简历中：扎实掌握原生JavaScript

## 基础数据类型和判断
8大数据类型（包括BigInt)
判断基础数据类型用 typeof   
判断复杂数据类型可以用 intanceOf
Object.prototype.toString().call() 可以通用
- 数据转换的规则和优先级
    toPrimitive方法
    valueOf,转换为基础类型，则返回
    toString,转化为基础类型
    如果都没有返回基础类型会报错。

**大概观念：**
1. 对于==隐式类型转化，双方为null或underfined，才为ture
2. 对于string number, boolean类型都转化为number
3. 如果是object转化为原始类型再进行判断
4. 对于+号的转大多是偏向于string

## 深浅拷贝
浅拷贝就是只复制基础数据类型，对于引用类型只复制一层引用地址。当原对象改变时会带动复制对象中的引用对象的值发生改变。深拷贝中对于复杂的引用对象就是重新建一个堆空间，然后把值复制到里面而不是只是简单复制一个地址。
- 浅拷贝
assign（obj, targget）
...拓展运算符

- 深拷贝
JSON.stringfly()和JSON.parse()这样的话能够进行简单的深拷贝，但是碰到一些复杂的类型和情况时会出现问题。
> 需要解决的问题：
1.日期和正则这种类型
2.循环引用问题
3.不可枚举的属性和Symbol类型
4.原型链的继承问题


## 继承相关
原型链继承
构造函数继承
原型构造函数继承（组合继承） 多次调用父类构造方法造成浪费
原型式继承 Object.create() 创建对象的原型对象，创建出来的对象可以通过__proto 链接到原型链上进行查找属性
寄生式继承
寄生组合式继承

多讲一下寄生组合式继承
所谓寄生就是用了在克隆里面添加一些方法，寄生组合继承就是构造函数+Object.create()+原型链绑定 prototype + constructor绑定。


原型链的那张图 和 廖雪峰的那个继承综合一下
js的继承就是一个属性和方法，如果一个对象没有就会沿着原型链上查找,原型链的最上游是null
原型对象会有constructor属性指向构造函数，构造函数会有prototype属性指向原型对象。
![](https://www.liaoxuefeng.com/files/attachments/1034288859918112/l)


extends的原理就是寄生组合式继承

## new apply bind call
new 执行一个构造函数返回一个对象，如果构造函数中return 一个对象,new讲返回这个；如果是非对象则返回new出来的对象。new的作用，创建一个新对象，改变this，执行构造函数的代码。

call 传散的 apply 传数组  bind传数组，返回一个绑定好的函数，call apply是立即执行。

## 闭包 
网络上看到闭包的解释太多了，我这里比较喜欢红宝书上上面的解释：闭包是指有权访问另一个函数作用域中变量的函数。通俗的说就是访问了外层函数作用域中的变量的函数。   
作用域链，当前函数会存在对外层函数作用域的引用，也就形成了一条作用域链

## 数组
数组方法： Array of() 快速创建数组  Array from() 基于迭代对象快速创建数组
- 改变自身的方法
    pop push shift unshift unpush reverse sort splice copyWithin fill

